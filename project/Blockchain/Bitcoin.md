---
created: <% tp.file.creation_date() %>
---

# ![[Pasted image 20221028145043.png|30]] Bitcoin 
%% 비트코인 체인에 대한 설명 %% 

## 💡 비트코인의 탄생

비트코인은 2008년 10월 사토시 나카모토라는 익명의 개인 or 단체가 만든 아래 논문에서 시작됨
이 논문을 Cypherpunk(암호 기술 활용 집단)와 공유하였고, 오픈소스 소프트웨어로 배포되어 현재까지 운용되고 있음

![[Pasted image 20221028103229.png]]

### 💵 화폐에 대해서...

돈은 그자체로 가치가 있는 것이 아니라 
내가 속한 공동체가 그 돈이 가치 있다고 신뢰하고 보증해 주기 때문에 가치가 있는 것

이전까지의 전자화폐는 디지털화된 데이터의 특성으로 복사가 쉬워 위조의 위험성이 높았다

⚠️ 전자화폐의 문제점
- 위조 문제, 이로 인한 신뢰성
- 한 사람이 가진 돈을 복사해 여러곳에 사용하는 이중지불 (Double spending)
- 내가 가진 전자화폐에 대한 소유권의 인정

<br />

#### ==**비트코인은 기존의 전자화폐 시스템의 문제점을 해결한 최초의 전자화폐 시스템**==



%%논문의 주요 내용%%
### 👥 P2P(peer-to-peer) Network (Decentralization)

⚠️ 기존의 전자화폐 복사 문제의 해결책
=> 은행과 같은 믿을 수 있는 제 3자에게 관리를 맡기는 것

![[Pasted image 20221028152118.png|500]]

제 3자가 개인 간 거래를 기록, 검증해주고
개인들은 이 제 3자를 신뢰하기 때문에 우리는 편리하게 전자화폐를 사용해 왔음

#### 🏦 중앙 집중 시스템의 문제점
- 장부가 한 곳에 집중되어 해킹의 타겟이 될 수 있음
- 이러한 집중 시스템이 손상되거나 공격 당하면 전체 네트워크의 기능에 영향을 끼침
- 중앙 기관의 무능, 부패로 제 3자 역할을 하는 기관을 믿을 수 없게 될 수 있음
- 네트워크 영속성을 위한 유지비용이 많이 듦

중앙 기관 없이도 데이터의 신뢰를 보증하기 위한 방법
#### 👥 P2P Network (peer-to-peer)
중앙시스템이 존재하지 않고 각 노드(컴퓨터)들이 대등한 위치에서 서로의 요청에 대해 서로 서비스하며 자율적으로 유지되는 네트워크
![[Pasted image 20221031100615.png|500]]
비트코인은 P2P (peer-to-peer) 네트워크로 각 노드들의 합의 절차를 거쳐 자발적으로 운영됨.
블록체인에 데이터를 추가하기 전에 다수의 노드가 합의를 달성해야 하기 때문에, 공격자가 데이터를 변조하는 것은 거의 불가능.
블록체인이 모든 기록을 공개적으로 기록하는 디지털 원장 역할

### 💸 이중지불문제 방지

합의 알고리즘 : 다수의 참여자들이 통일된 의사결정을 하기 위해 사용하는 알고리즘

#### 🧑‍💻Proof of Work (작업증명) 방식의 합의 시스템
- 블록을 생성하기 위해 해시값을 찾는 작업을 특정한 난이도에 수행하고 이를 증명하는 것.
- 증명은 채굴(mining) 으로 이루어짐.
- 문제를 빨리 해결한 사람에게 블록을 생성할 수 있는 권한을 부여하고 이에 대한 보상으로 비트코인을 제공. (새로 발행되는 비트코인 + 해당 블록에 포함된 거래 수수료)
- 문제는 해시 함수의 결과값이 블록 해시가 설정한 특정 값보다 작아지도록 하는 입력 값(Nonce)를 찾는 것
- 문제의 난이도는 약 10분 걸려서 풀릴 수 있는 난이도.
<br>
## 🏷️ 블록체인 구조
![[Pasted image 20221031000313.png]]

##### 블록헤더
- 블록의 버전 (Version)은 비트코인 S/W의 버전 정보임. 
- S/W가 업그레이드되면서 추가된 기능을 Version으로 표시함. Genesis block의 version = 1 이었고, version = 2,3,4 까지 진행되다가, 현재는 BIP-9 표준으로 Soft Fork가 진행될 때 Miner들이 어떤 기능을 지원하는지 표시함.
    
- Previous block header hash는 이전 블록 헤더의 해시 값임. 
- 이 값은 이전 블록을 가리키는 해시 포인터 역할을 하고, 블록들을 체인으로 연결함. 이 블록 안에 있 는 임의의 거래 내역 (Transaction)이 변조되면 블록 헤더의 해시 값이 변하므로 다음 블록으로의 연결이 끊어짐. 블록 안에 있는 거래들은 변경될 수 없음.
    
- Merkle Root는 거래 내역들을 요약한 정보임 (Merkle Tree의 Root). 
- 일부 거래 내역이 변조되면 Merkle Root가 변경되므로 블록 헤더가 변하고, 블록 헤더의 해시 값이 변하므로 블록의 체인이 끊어짐. Merkle Root는 특정 거래가 이 블록에 존재하는지 확인할 때 사용될 수 있음 (SPV가 자신의 거래가 이 블록에 실재하는지 확 인할 때도 사용됨).
    
- Timestamp는 이 블록이 생성된 날짜, 시간임. 시간은 UTC (세계 협정시, 영국 그리니치 천문대 기준) 기준임.
    
- Bits (or Target) 와 Nonce는 Miner가 블록을 생성할 때 블록 해시 값의 최솟값과 관련이 있음 (난이도 변수). 계산한 블록 해시 값이 Bits에서 제시하는 값 이하 (블록 해시 앞 부분의 0의 개수)가 되도록 Nonce 값을 설정해야 함. 즉 Miner는 이 조건을 만족하는 Nonce 값을 찾는 것이 관건임.  
- 이 블록 헤더 자체의 해시 값은 저장되어 있지 않음. 필요시 헤더로부터 계산해서 사용함 (double-SHA256 해시).

##### 거래 내역
- Transaction Count는 거래 내역의 총 개수임.
    
- Coinbase Transaction은 Miner가 이 블록을 생성한 대가로 받은 보상을 (현재는 12.5 BTC + Fee) 자기 지갑으로 송금하는 거래임. 대가를 누가 지급하는 것이 아니라 Miner 스스로 챙기는 것임. 비트코인 총 발행량은 블록이 생성될 때마다 (약 10분 마다)  6.25 BTC (현재 기준으로)씩 증가함.
    
- Transaction 들은 비트코인 네트워크에서 발생한 (약 10분 동안) 거래 들임. 이 블록이 블록체인에 등록되면 (정확히는 이후 6개 이상의 블록들이 쌓이면), 거래들이 최종 승인된 것임. Miner가 이 거래들을 승인한 것이고, Miner는 그 대가로 보상을 받는 시스템임.  비트코인 네트워크의 핵심 부분이라 할 수 있음.

## 📬 Wallet (지갑)

비트코인 지갑은 비트코인의 잔고를 보관하는 것이 아니라, 개인키, 공개키, 지갑 주소를 관리하는 것이 목적임.

비트코인의 잔액은 지갑에 보관되는 것이 아니라 네트워크 상의 블록체인에 기록되어 있음. 
거래 내역에 누구로부터 얼마를 받았고, 이 중 얼마를 사용하지 않았다는 기록 (UTXO : Unspent transaction output)이 해당 지갑의 잔고 (Balance) 임.




### 👛 지갑주소 생성과정
1. 개인키 생성
2. ECC (타원곡선) 알고리즘을 통해 공개키 생성
3. 공개키로 공개키 해시 계산
4. 공개키 해시로 지갑 주소 생성

![[Pasted image 20221028184041.png|700]]

공개키 (K) = G + G + G + ... + G (개인키 만큼 덧셈)로 계산 (타원곡선 상의 점 G)
공개키만 알고 개인키를 찾으려면 개인키가 큰 수이기 때문에 (2^256) 일일이 계산하는 것은 현실적으로 가능하지 않음.

공개키 -> 공개키 해시는 역변환이 불가 (One way)
공개키 해시 -> 지갑 주소는 상호 변환이 가능함. (둘은 동일한 정보)

사용자는 지갑 주소를 이용하여 잔고를 관리하거나 입.출금하지만, 블록체인 데이터에는 지갑 주소가 기록되지 않고 지갑 주소의 공개키 해시 값이 기록됨
거래를 생성할 때 지갑 주소를 공개키 해시 값으로 변환하여 Transaction에 기록

참고 )
- 타원곡선 알고리즘
	+ 공개키는 개인키를 이용해 타원곡선 암호 방식으로 생성. 
	+ 공개키는 타원곡선 상 (실제 타원은 아님)의 점 G를 개인키 만큼 곱한 것으로 정의함. 
	+ 공개키 (K) = 개인키 * G.타원곡선 상의 한 점.
- Base58Check
	+ Base58Check 인코딩은 숫자나 문자열을 읽기 쉬운 형태의 문자열로 변환하는 알고리즘.
	+ 개인키, 공개키, 지갑 주소와 같은 매우 긴 숫자를 문자열로 바꾸면 가독성도 좋아지고, 외우기가 쉽다.
	참고 : https://brunch.co.kr/@skkrypto/122

#### 🔐 지갑 키 관리

Nondeterministic wallet (비결정적 지갑) - Type 0
-   다수의 지갑 주소를 Random 생성하는 방법
-  키들 간의 연관성이 없기 때문에 안전한 방식일 수 있으나, 빈번히 바뀌는 많은 키를 자주 백업 관리하기 어려움.

Deterministic wallet (결정적 지갑) - Type 1
- Seed 값을 생성 한 후 해시 함수를 이용하여 다수의 키를 생성.
- 키 간의 연관성이 존재할 수 있지만 Seed 값만 백업 보관하면 나머지 키들은 언제든지 복원할 수 있음.
- Tree 형태로도 발전하고 있으며, BIP-32로 제안된 HD wallet (Type-2) 방식이 널리 사용되고 있음.



#### 🏷️ HD Wallet 구조 (Hierarchical Deterministic Wallet)
- 계층 구조
- Seed 값으로 마스터 개인키와 마스터 공개키를 생성하고 마스터 키로 하위 계층의 키와 주소를 생성함.
![[Pasted image 20221028183611.png]]

HD Wallet의 장점
-  Tree의 Branch 별로 지갑의 용도를 달리할 수 있음
- 하위 계층의 지갑 주소는 개인키 없이 공개키 만으로도 만들 수 있어 개인키를 노출하지 않아도 됨.
	- 하위 계층의 공개키는 개인키로 만드는 것이 아니라 상위 계층의 공개키 로 만들 수 있음. 지갑 주소를 만들 때 개인키가 사용되지 않음.

#### 🔐 지갑 키 관리 : BIP-39 + BIP-32
- Deterministic wallet의 Seed 값은 Random 생성, Passphrase (문장), Mnemonic Code (단어 목록)등을 이용할 수 있음.
- 사용자가 임의로 문장이나 단어 목록을 지정하면 Brain wallet 방식이 되고, 랜덤하게 선택하면 Mnemonic Code wallet 방식이 됨.
- 일반적으로 사용자가 지정하는 방식보다는 사전에서 랜덤하게 선택하는 방법이 훨씬 안전한 것으로 알려져 있음.
- HD wallet의 Seed 값을 Mnemonic Code로 생성하면 효과가 극대화됨. (BIP-39 + BIP-32).

<br>

## 📝 Transacion (거래)

### 📒 UTXO (Unspent Transaction Outputs)

미사용 트랜잭션 출력값. 아직 쓰지 않은 잔액.
암호화되어 블록체인상에 저장되어 있는 단위
암호화된 UTXO는 사용시점에 소유자만이 암호를 해제하여 거래의 입력값으로 사용
비트코인에서는 트랜잭션에 의한 결과물들의 합을 잔액이라는 개념으로 사용, 이것을 UTXO로 대체
블록체인에 기록된 소비되지 않은 출력값을 통해 거래의 유효성을 검사하여 코인의 존재 여부를 확인

### 💎 트랜잭션 작동원리

![[Pasted image 20221030155006.png]]

0. Bob이 50BTC를 가지고 있고, Alice에게 0.5BTC 전송하려 함.
1. Bob은 50BTC의 unspent output (미사용 출력값)을 가져와 트랜잭션의 input(입력) 으로 사용
2. 개인키로 이 입력에 전자 서명을 하여 잠금 해제, Alice에게 0.5BTC를 보낸다는 내용과 나머지는 다시 자신에게 보낸다는 내용을 기록
	(만약 output에 나머지 금액을 자신에게 보낸다는 항목이 없으면 이 금액은 채굴자에게 지불된 거래 수수료로 사용됨)
3. Alice 는 이전에 받은 0.1BTC와 0.2BTC에 추가로 Bob에게서 0.5BTC를 받음
4. Alice가 직원에게 0.8BTC를 보내고자 할 때, 1)보낼 금액과 같은, 2)보낼 금액보다 큰 UTXO를 찾고 3)없을 경우 여러개의 UTXO를 합치는 순으로 새로운 UTXO 객체를 만들어 하나의 입력을 생성하고 개인키로 서명해 트랜잭션을 보낸다

UTXO 장단점
장점:
- 거래의 유효성 검증이 쉽다. 해당 사용자의 UTXO만 확인하면 된다.
- 1회성. 한번 사용되면 사라지기 때문에 익명성과 보안성이 강하다.
단점 :
- UTXO가 많이 생성될 경우 흩어져 있는 UTXO를 모두 모아야 하고, 
 UTXO마다 수수료가 부과되기 때문에 수수료가 커진다.
<br>
### 💎 거래 유효성 검증
발생된 거래가 블록체인상에 전송되어 각 사용자가 유효한지 검증
이렇게 검증이 된 거래만이 채굴을 통해 메인체인에 포함이 될 수 있음.

동작 원리
1. 먼저 거래의 송신자는 거래메세지를 작성하고 해당 메세지를 자신의 개인키로 암호화하여 전자서명을 만듦
	이렇게 만든 서명은 자신의 공개키로만 복호화 가능
2. 서명을 자신의 거래 메세지와 함께 블록체인상에 전송하고 암호화에 사용한 공개키도 함께 공개
3. 이 거래메세지를 수신한 수신자들은 해당 거래에 포함된 서명을 공개된 공개키로 복호화 하여 포함된 메세지와 비교
4. 원본과 공개키로 복호화된 메세지가 동일하다면 해당 거래는 정상적인 개인키로 암호화된것으로 판단할수 있기 때문에 유효한 거래로 판명되어 연속적으로 블록체인상에 전파됨.
![[Pasted image 20221031121525.png|800]]

### 💎 타임 스탬프 서버
![[Pasted image 20221031145639.png|800]]
이중 지불 되지 않았음을 증명하는 어떤 거래가 먼저인지 결정하는 시스템.
모든 거래에 타임 스탬프를 찍어 순서를 비교.
블록에는 시간 단위별로 묶은 여러 개의 거래 내역이 담겨 있음. 
이 블록을 해시하여 해시값이 만들어지는 시점이 곧 타임스탬프가 되는 것.
타임 스탬프 서버를 통해 여러 거래를 시간 단위로 묶고 각 타임 스탬프는 직전 거래의 타임스탬프를 포함하도록 한다.

%% ### 💎 거래 승인 절차

1) 트랜잭션 생성, 발송
	- 송금 트랜잭션 생성 시 생성한 트랜잭션을 인근 노드들에게 전송
2) Relay
	- 인근 노드가 해당 트랜잭션의 유효성을 검증, 다른 인근 노드로 트랜잭션을 전달
3) 블록 생성
	- Miner 노드가 트랜잭션을 받아 유효성, 수수료 적정성을 확인한 후 다른 트랜잭션과 합쳐 새로운 블록 생성
	- Miner 노드들은 경쟁적으로 블록을 생성해 다른 노드들에 전송 (거래 승인 과정 : PoW)
	- Miner가 생성한 블록에는 자신의 지갑으로 비트코인과 트랜잭션에 포함된 수수료를 보냄 (거래 승인의 대가)
4) 블록추가
	- Full 노드가 새로운 블록을 받으면 유효성 검증 후 블록체인에 블록을 연결. 거래내역이 블록체인에 기록되고 거래가 완료됨
5) 블록 동기화
	- 새로운 블록이 블록체인에 연결되면 다른 Full노드들과 동기화 함

Miner가 트랜잭션을 새로운 블록에 기록하면 송금 거래가 승인된 것. (이후 6개 정도의 블록이 추가되어야 완전히 승인된 것)
트랜잭션의 잔고가 이미 사용되었으면 UTXO가 아님. 더 이상 사용할 수 없음.(Spent 상태). => 이중 지불 문제 해결.

%%
## 💰 Mining (채굴)

비트코인을 생산하는 과정.
- 채굴노드가 블록을 생성하여 메인 체인에 연결하기위해서는 먼저 거래가 포함된 블록을 생성
- 블록을 생성하기 위해서 채굴노드는 먼저 검증된 거래가 들어있는 메모리풀(Memory pool) 또는 거래풀(Transaction pool)에서 조건에 맞는 거래들은 선별하여  블록을 구성
- 거래가 거래풀에 들어오기 위해서는 사전에 해당 거래가 유효함이 검증되어야 하며, 이 조건에 통과된 검증된 거래만 거래풀에 들어옴

![[Pasted image 20221031152106.png|600]]

- 채굴노드가 거래풀에서 거래를 선택하는것은 각 거래의 우선순위를 기준
	* 우선순위 = Sum ( 거래 수수료 * 거래 나이 ) / 거래 크기

- 채굴노드 1과 2가 서로 경쟁하여 노드 1이 채굴에 성공한경우, 해당 블록은 메인체인에 연결이 되고 블록체인상의 모든 노드에게 전송
- 아직 채굴이 진행중인 채굴노드 2가 이와같이 새로 생성된 블록을 받게되면 자신의 작업증명을 중지한 후, 
 자신이 작업중인 헤더에서 새로운 블록에 포함된 거래를 제거하고(4번 거래를 제거), 다시 거래풀에서 새로운 거래들을 가져와 새로운 헤더를 구성하고 다시 작업증명을 시작
 - 채굴 노드는 이과정을 무한 반복

### 채굴노드가 블록 생성에 성공했음을 알리는 작업 증명 (Proof of Work)
![[Pasted image 20221031154927.png|500]]
p2p network에서 타임스탬프 서버 구현을 위해 만듦

블록헤더를 사용해 블록의 해시 값 계산
블록헤더는 Previous Hash, Merkle Root, Timestamp, Bits, Version, Nonce 6개로 구성되며, 이중 Nonce를 제외한 5개의 값은 고정된 상수값
블록 헤더의 해시 값이 Bits 에서 제시하는 난이도에 만족하면 Mining에 성공한 것이고, 만족하지 못하면 nonce 값을 증가시켜 가면서 난이도 조건에 만족할 때까지 반복함.
* Bits 값 = 난이도 목표값 
해당 목표값보다 작은 Hash값이 발견되면 작업증명이 완료. 각 노드에 생성한 블록을 전파
![[Pasted image 20221031150304.png]]

%%
- Miner는 트랜잭션들을 모아서  새로운 블록을 생성함. Tx 집합의 첫 번째는 Mining의 보상을 자신에게 송금하는 Tx 임. -> Coinbase Transaction.  
- Tx 들로 Merkle Root(거래내역 요약 정보)를 계산하고, 이전 블록의 해시 값 등을 이용하여 블록 헤더를 생성하고 (nonce는 초깃값 = 0), 블록 헤더의 해시 값을 계산함.  
- 블록 헤더의 해시 값이 Bits 에서 제시하는 난이도에 만족하면 Mining에 성공한 것이고, 만족하지 못하면 nonce 값을 증가시켜 가면서 난이도 조건에 만족할 때까지 반복함. 헤더의 해시 값의 앞 부분에 ‘0’이 많이 붙어야 난이도 조건을 만족함.
- 채굴과정의 작업증명은 타겟 난이도값보다 작은값을 발견하는 과정
%%
<br>
%%
### 🩹👌🏆 💎 네트워크 동작 방식
1. 새로운 트랜잭션 (거래 내역) 들은 모든 노드에 전파
2. 각 노드는 새로운 트랜잭션을 하나의 블록에 모음
3. 각 노드는 자신의 블록 생성을 위해 작업증명 작업 수행
4. 한 노드가 하나의 작업증명 해답을 찾으면 그 블록을 모든 노드에 전파
5. 노드들은 작업증명이 끝난 블록에 포함된 모든 거래가 유효하고 이전에 중복사용된 것이 아닌 때에만 그 블록을 수용
6. 노드들은 자신이 해당 블록을 수용했다는 의사표시로 자신이 수용한 블록의 해시값을 바로 직전의 해시값으로 사용하여 체인 내에 다음 블록을 생성하는 작업을 수행함으로써 표현
%%
<br>

## 🎇 구현방법
%%앞선 DAKI를 통해서 무엇을 얻을 수 있었나요?  또는 이번 프로젝트 또는 스프린트를 진행하면서 어떤 점을 느꼈나요? %%
- bitcore-lib, bitcore-mnemonic 라이브러리를 사용해 HD wallet 생성, 
- API 활용해 전송기능 찾아보기

<br>

## 🧑‍⚖️ Decision
%%회고를 통해서 앞으로 더 좋은 방향으로 나아가기 위해서 결정해야할 사항들은 어떤 것들이 있었나요? %%
- 결정해야할 사항


참고 :
http://blog.naver.com/chunjein
https://brunch.co.kr/@bumgeunsong/41